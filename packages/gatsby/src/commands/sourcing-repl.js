const fs = require(`fs-extra`)
const path = require(`path`)
const readline = require(`readline`)
const { createMachine, interpret } = require(`xstate`)
const chokidar = require(`chokidar`)
const { getNodes, getNode, getNodesByType } = require(`../datastore`)
const getDiff = require(`./get-diff`).default
const reducer = require(`./sourcing-event-reducer`).default

const stream = fs.createWriteStream(`/tmp/events.jsonl`, { flags: `a` })
let clientSocket

function writeEventToFile(event) {
  console.log(`writeEventToFile`, { event })
  clientSocket.emit(`event`, event)
  reducer(event)
  stream.write(JSON.stringify(event) + `\n`)
}

const {
  updateInternalSiteMetadata,
  isTruthy,
  uuid,
} = require(`gatsby-core-utils`)

const {
  srcLocation,
  requireFromSiteGatsbyDist,
  requireFromSiteModules,
} = require(`./local-require`)

const reporter = requireFromSiteModules(`gatsby-cli/lib/reporter`)
const { initTracer } = requireFromSiteGatsbyDist(`utils/tracer`)
const { emitter } = requireFromSiteGatsbyDist(`redux/index`)

const { initialize } = requireFromSiteGatsbyDist(`services/initialize`)
const { customizeSchema } = requireFromSiteGatsbyDist(
  `services/customize-schema`
)

export const bootstrapState = {
  realProgramDirectory: null,
}

async function bootstrapGatsby(program, externalTelemetryAttributes) {
  // Resolve symlinks. This is necessary so this path + any
  // generated by gatsby-source-filesystem match.
  const realProgramDirectory = await fs.realpath(program.directory)

  // @todo this is a bad pattern. we only need the realProgramDirectory to rewrite actions
  // but we should rethink how/where/when we rewrite actions
  bootstrapState.realProgramDirectory = realProgramDirectory

  // global gatsby object to use without store
  global.__GATSBY = {
    buildId: uuid.v4(),
    root: realProgramDirectory,
  }

  if (isTruthy(process.env.VERBOSE)) {
    program.verbose = true
  }

  reporter.setVerbose(program.verbose)

  await updateInternalSiteMetadata({
    name: program.sitePackageJson.name,
    sitePath: realProgramDirectory,
    lastRun: Date.now(),
    pid: process.pid,
  })

  if (!externalTelemetryAttributes) {
    await initTracer(
      process.env.GATSBY_OPEN_TRACING_CONFIG_FILE ||
        program.openTracingConfigFile
    )
  } else {
    Object.entries(externalTelemetryAttributes).forEach(([key, value]) => {
      bootstrapSourcererActivity.span.setTag(key, value)
    })
  }

  const bootstrapSourcererActivity =
    reporter.phantomActivity(`bootstrap sourcerer`)
  bootstrapSourcererActivity.start()

  const bootstrapContext = {
    program,
    parentSpan: bootstrapSourcererActivity.span,
    realProgramDirectory,
  }

  const context = {
    ...bootstrapContext,
    ...(await initialize(bootstrapContext)),
  }

  await customizeSchema(context)

  emitter.emit(`BOOTSTRAP_FINISHED`)
  bootstrapSourcererActivity.end()
  console.info(`Bootstrap finished in ${process.uptime()} sec`)

  return { context, realProgramDirectory }
}

// Listen for events
emitter.on(`CREATE_NODE`, action => {
  console.log(`CREATE_NODE`, {
    plugin: action.plugin.name,
    type: action.payload.internal.type,
    id: action.payload.id,
  })
  if (action.oldNode) {
    const oldNode = JSON.parse(JSON.stringify(action.oldNode))
    const newNode = JSON.parse(JSON.stringify(action.payload))
    delete oldNode.internal.counter
    delete oldNode.internal.contentDigest
    delete newNode.internal.counter
    delete newNode.internal.contentDigest
    action.diff = getDiff(oldNode, newNode)
  }
  action.timestamp = new Date().getTime()
  writeEventToFile(action)
})
emitter.on(`DELETE_NODE`, action => {
  console.log({ delete: action })
  console.log(`DELETE_NODE`, {
    plugin: action.plugin.name,
    type: action.payload.internal.type,
    id: action.payload.id,
  })
  action.timestamp = new Date().getTime()
  // console.log(getDiff(action.oldNode, action.payload))
  writeEventToFile(action)
})
emitter.on(`SOURCING_STARTED`, event => {
  writeEventToFile({ type: `SOURCING_STARTED`, ...event })
  console.log(`SOURCING_STARTED`, { event })
})
emitter.on(`SOURCING_ENDED`, event => {
  console.log(`SOURCING_ENDED`, { event })
  writeEventToFile({ type: `SOURCING_ENDED`, ...event })
})

const program = {
  directory: srcLocation,
  sitePackageJson: require(path.join(srcLocation, `package.json`)),
  noUglify: false,
  host: process.env.HOSTNAME,
  port: 10000,
  version: `1.0.0`,
  prefixPaths: false,
}

const sourceStudioMachine = createMachine({
  id: `studio`,
  initial: `idle`,
  context: {
    retries: 0,
  },
  states: {
    idle: {
      invoke: {
        id: `promptUser`,
        src: () => callback => {
          const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
          })

          rl.question(
            `a: source from all plugins
b: source from default plugin
cc: clear caches

> `,
            async answer => {
              if (answer === `a`) {
                callback(`INPUT_SOURCING`)
              }
            }
          )

          // Perform cleanup
          return () => rl.close()
        },
      },
      on: {
        INPUT_SOURCING: `sourcing`,
        RESOURCE: `sourcing`,
        SOURCE_FILE_CHANGED: `sourcing`,
      },
    },
    sourcing: {
      invoke: {
        id: `sourceNodes`,
        src: async context => {
          const defaultSitePluginPath = path.join(
            context.store
              .getState()
              .flattenedPlugins.find(
                plugin => plugin.name === `default-site-plugin`
              ).resolve,
            `gatsby-node.js`
          )

          delete require.cache[defaultSitePluginPath]

          const { sourceNodes } = requireFromSiteGatsbyDist(
            `services/source-nodes`
          )

          console.log(`\n---\n`)
          await sourceNodes({ ...context })
          console.log(
            getNodes().filter(node => {
              if ([`internal-data-bridge`].includes(node.internal.owner)) {
                return false
              }

              return true
            })
          )
          console.log(`\n---\n`)
          return
        },
        onDone: {
          target: `idle`,
        },
        onError: {
          target: `idle`,
        },
      },
    },
  },
})

async function main() {
  const { context } = await bootstrapGatsby(program)
  // Interpret the machine, and add a listener for whenever a transition occurs.
  const service = interpret(
    sourceStudioMachine.withContext(context)
  ).onTransition(state => {
    // console.log(`[state change]`, state.value, state.event)
  })

  // Start the service
  service.start()

  // Watch the gatsby-node.js for changes. In the future this
  // needs to handle all plugis + imported files.
  const defaultSitePluginPath = path.join(
    context.store
      .getState()
      .flattenedPlugins.find(plugin => plugin.name === `default-site-plugin`)
      .resolve,
    `gatsby-node.js`
  )
  chokidar
    .watch([defaultSitePluginPath], { ignoreInitial: true })
    .on(`change`, path => {
      service.send({ type: `SOURCE_FILE_CHANGED` })
    })

  const headers = {
    "Access-Control-Allow-Origin": `*` /* @dev First, read about security */,
    "Access-Control-Allow-Methods": `OPTIONS, POST, GET`,
    "Access-Control-Max-Age": 2592000, // 30 days
    /** add other headers as per requirement */
  }

  const httpServer = require(`http`).createServer(function (req, res) {
    if (req.method === `POST`) {
      res.writeHead(200, headers)
      service.send({ type: `RESOURCE` })
      res.end()
    }
  })
  const options = {
    cors: {
      origin: `http://localhost:1234`,
      methods: [`GET`, `POST`],
    },
  }

  const io = require(`socket.io`)(httpServer, options)

  io.on(`connection`, socket => {
    console.log(`new connection`)
    clientSocket = socket
  })

  httpServer.listen(3000)
}

main()

exports.bootstrapGatsby = bootstrapGatsby
